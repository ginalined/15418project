#include "VCScene.h"
#include <iostream>

const int VC_ERR_INVALID_ID            = -4; //invalid id was passed to the
                                             //routine.
const int VC_ERR_EMPTY_OBJECT          = -3; //EndObject called without adding
                                             //adding any triangles.
const int VC_ERR_CALL_OUT_OF_SEQUENCE  = -2; //calls out of sequence.
const int VC_ERR                       = -1; //some other error.
const int VC_OK                        =  1; //No error.




void SimplfiedObj::addTri(double p1[], double p2[], double p3[]) {
    // first make sure that we haven't filled up our allocation.
  // if we have, allocate a new array of twice the size, and copy
  // the old data to it.

  if (triSize == triBufferSize)
    {
      // decide on new size -- accounting for first time, where none are 
      // allocated
      int n = triBufferSize*2;

      // make new array, and copy the old one to it
      SimplifyTri *t = new SimplifyTri[n];

      int i;
      for(i=0; i<triSize; i++) {
        t[i] = triList[i]; 
      }

      // free the old array and reassign.  
      delete [] triList;
      triList = t;
      
      // update the allocation counter.
      triBufferSize = n;
    }

  // now copy the new tri into the array
  triList[triSize].p1[0] = p1[0];
  triList[triSize].p1[1] = p1[1];
  triList[triSize].p1[2] = p1[2];
  triList[triSize].p2[0] = p2[0];
  triList[triSize].p2[1] = p2[1];
  triList[triSize].p2[2] = p2[2];
  triList[triSize].p3[0] = p3[0];
  triList[triSize].p3[1] = p3[1];
  triList[triSize].p3[2] = p3[2];
  triList[triSize].id = triSize;

  // update the counter
  triSize++;
}

static double area2D(double x1, double x2, double x3, double y1, double y2, double y3) {
    return abs((x1*(y2-y3) + x2*(y3-y1)+ x3*(y1-y2))/2.0);
}

static bool isInside(double x1, double x2, double x3, double y1, double y2, double y3, double p[]) {
    // credit to https://www.geeksforgeeks.org/check-whether-a-given-point-lies-inside-a-triangle-or-not/
    double A = area2D(x1, x2, x3, y1, y2, y3);
    double A1 = area2D(x1, x2, p[0], y1, y2, p[1]);
    double A2 = area2D(x3, x2, p[0], y3, y2, p[1]);
    double A3 = area2D(x1, x3, p[0], y1, y3, p[1]);
    return (A1 + A2 + A3) == A;
}

// tri[3], trans[16]
void VCScene::transTri(double *tri, double *trans) {
    // {4 * 4} * {4 * 1}, last entry of tri = 1
    const int LINE_SIZE = 4;
    double output[LINE_SIZE];
    for (int i = 0; i < LINE_SIZE; i ++) {
        output[i] = 0;
        for (int j = 0; j < LINE_SIZE; j ++) {
            if (j == LINE_SIZE - 1) {
                output[i] += trans[i * LINE_SIZE + j];
            } else {
                output[i] += trans[i * LINE_SIZE + j] * tri[j];
            }
            // std::cout << "output[" << i << "] += trans[" << i << "][" << j << "] * tri[" << j <<"]" << std::endl;
        }

        if (output[3] != 1) {   // normalization
            for (int j = 0; j < LINE_SIZE - 1; j ++) {
                output[j] = output[j] / output[3];
            }
        }
        // std::cout << "output[" << i << "] += trans[" << i << "][" << 3 << "]" << std::endl;
        if (i != LINE_SIZE - 1)
            tri[i] = output[i];
    }
}

VCScene::VCScene(int size) {
    image = NULL;
    size = size;
    next_id = 0;
    current_id = 0;
    vc_objects = new SimplfiedObj*[size]; //allocate the array.
    int i;
    for (i=0; i<size; i++)
        vc_objects[i] = NULL;
}

VCScene::~VCScene() {
    int i;
    for (i=0; i<size; i++){
        if (vc_objects[i]) {
	        delete vc_objects[i]->triList;
	        // delete vc_objects[i];
	    }
    }
    delete [] vc_objects;
}

int VCScene::NewObject(int *id) //create a new object in the database.
{
  //allocate a new object.
//   std::cout<< "allocate a new object" << std::endl;
  vc_objects[next_id] = new SimplfiedObj;
  if (vc_objects[next_id] == NULL)
    return VC_ERR;
  
  *id = next_id;  //for returning the id generated by VCollide.
  current_id = next_id;
  
  vc_objects[next_id]->id = next_id;

  vc_objects[next_id]->triBufferSize = 4;   // initialize from 4, grow by twice
  vc_objects[next_id]->triList = new SimplifyTri[vc_objects[next_id]->triBufferSize];
  vc_objects[next_id]->triSize = 0;

  next_id++;
  
  return VC_OK;
}

int VCScene::AddTri(double v1[], double v2[], double v3[]) 
{                     //add geometry to the newly created object.   
  vc_objects[current_id]->addTri(v1, v2, v3);  //add triangle.
  return VC_OK;
}

int VCScene::EndObject() {
    memset( ( (void *)vc_objects[current_id]->trans), 0, 16*sizeof(double) );
    vc_objects[current_id]->trans[0] = 1.0;
    vc_objects[current_id]->trans[5] = 1.0;
    vc_objects[current_id]->trans[10] = 1.0;
    vc_objects[current_id]->trans[15] = 1.0;

    // std::cout << "current_id = " << current_id << std::endl;
  
  return VC_OK;
}

int VCScene::UpdateTrans(int id, double *trans) {
    SimplfiedObj *current = vc_objects[id];
    //update the private copy of the transformation matrix.
    memcpy((void *)current->trans, (void *)trans, 16*sizeof(double));
    return VC_OK;
}

void VCScene::allocateImage(int width, int height) {
    if (image)
        delete image;
    image = new Image(width, height);
}

Image *VCScene::getImage() {
    return image;
}

void VCScene::clearImage() {
    image->clear(1.f, 1.f, 1.f, 1.f);                                                                                             
}

void VCScene::dumpTriangles(FILE *fp) {
    for (int objIndex = 0; objIndex <= current_id; objIndex ++) {
        for (int triIndex = 0; triIndex <= vc_objects[objIndex]->triSize; triIndex ++) {
            SimplifyTri cur = vc_objects[objIndex]->triList[triIndex];
                      
            transTri(cur.p1, vc_objects[objIndex]->trans);
            transTri(cur.p2, vc_objects[objIndex]->trans);
            transTri(cur.p3, vc_objects[objIndex]->trans);
            // vc_objects[objIndex]->triList[triIndex] = cur;

            if (objIndex == 0 && triIndex == 0) {
                // std::cout << "after trans:\t" << cur.p1[0] << "\t" << cur.p1[1] << "\t" << cur.p2[2] << std::endl;
            }

            fprintf(fp, "%lf %lf %lf ", cur.p1[0], cur.p1[1], cur.p1[2]);
            fprintf(fp, "%lf %lf %lf ", cur.p2[0], cur.p2[1], cur.p2[2]);
            fprintf(fp, "%lf %lf %lf ", cur.p3[0], cur.p3[1], cur.p3[2]);
            fprintf(fp, "%lf\n", (double)objIndex);
        }
    }
}

void VCScene::render() {
    // render all object
    for (int objIndex=0; objIndex <= current_id; objIndex++) {
        for (int triIndex = 0; triIndex <= vc_objects[objIndex]->triSize; triIndex ++) {
            // determine the triangle processed by transformation matrix
            SimplifyTri cur = vc_objects[objIndex]->triList[triIndex];
            // if (objIndex == 0 && triIndex == 0)
            //     std::cout << "before trans:\t" << cur.p1[0] << "\t" << cur.p1[1] << "\t" << cur.p2[2] << std::endl;
            transTri(cur.p1, vc_objects[objIndex]->trans);
            transTri(cur.p2, vc_objects[objIndex]->trans);
            transTri(cur.p3, vc_objects[objIndex]->trans);
            // if (objIndex == 0 && triIndex == 0) {
            //     std::cout << "trans matrix:\t" << vc_objects[objIndex]->trans[0] << "\t" << vc_objects[objIndex]->trans[1] << "\t" << vc_objects[objIndex]->trans[2] << "\t" << vc_objects[objIndex]->trans[3] << "\n\t\t\t" << vc_objects[objIndex]->trans[4] <<"\t" << vc_objects[objIndex]->trans[5] <<"\t" << vc_objects[objIndex]->trans[6] <<"\t"  << vc_objects[objIndex]->trans[7] << "\n\t\t\t"<< vc_objects[objIndex]->trans[8] <<"\t" << vc_objects[objIndex]->trans[9] <<"\t" << vc_objects[objIndex]->trans[10] <<"\t" << vc_objects[objIndex]->trans[11] << "\n\t\t\t" << vc_objects[objIndex]->trans[12] <<"\t" << vc_objects[objIndex]->trans[13] <<"\t" << vc_objects[objIndex]->trans[14] << "\t" << vc_objects[objIndex]->trans[15] << std::endl;
            //     std::cout << "after trans:\t" << cur.p1[0] << "\t" << cur.p1[1] << "\t" << cur.p2[2] << std::endl;
            // }

            // compute the bounding box of the circle.  This bounding box
            // is in normalized coordinates
            float minX = std::min(std::min(cur.p1[0], cur.p2[0]), cur.p3[0]);
            float maxX = std::max(std::max(cur.p1[0], cur.p2[0]), cur.p3[0]);
            float minY = std::min(std::min(cur.p1[1], cur.p2[1]), cur.p3[1]);
            float maxY = std::max(std::max(cur.p1[1], cur.p2[1]), cur.p3[1]);

            // convert normalized coordinate bounds to integer screen
            // pixel bounds.  Clamp to the edges of the screen.
            int screenMinX = CLAMP(static_cast<int>(minX * image->width), 0, image->width);
            int screenMaxX = CLAMP(static_cast<int>(maxX * image->width)+1, 0, image->width);
            int screenMinY = CLAMP(static_cast<int>(minY * image->height), 0, image->height);
            int screenMaxY = CLAMP(static_cast<int>(maxY * image->height)+1, 0, image->height);

            int screenX1 = CLAMP(static_cast<int>(cur.p1[0] * image->width), 0, image->width);
            int screenY1 = CLAMP(static_cast<int>(cur.p1[1] * image->height), 0, image->height);
            int screenX2 = CLAMP(static_cast<int>(cur.p2[0] * image->width), 0, image->width);
            int screenY2 = CLAMP(static_cast<int>(cur.p2[1] * image->height), 0, image->height);
            int screenX3 = CLAMP(static_cast<int>(cur.p3[0] * image->width), 0, image->width);
            int screenY3 = CLAMP(static_cast<int>(cur.p3[1] * image->height), 0, image->height);            

            // for each pixel in the bounding box, determine the circle's
            // contribution to the pixel.  The contribution is computed in
            // the function shadePixel.  Since the circle does not fill
            // the bounding box entirely, not every pixel in the box will
            // receive contribution.
            for (int pixelY=screenMinY; pixelY<screenMaxY; pixelY++) {

                // pointer to pixel data
                float* imgPtr = &image->data[4 * (pixelY * image->width + screenMinX)];

                for (int pixelX=screenMinX; pixelX<screenMaxX; pixelX++) {
                    double p[] = {pixelX, pixelY};
                    if (!isInside(screenX1, screenX2, screenX3, screenY1, screenY2, screenY3, p)) {
                        continue;
                    }

                    // shader: black
                    imgPtr[0] = 0.f;
                    imgPtr[1] = 0.f;
                    imgPtr[2] = 0.f;
                    imgPtr[3] = 1.f;

                    imgPtr += 4;
                }
            }
        }
    }
}