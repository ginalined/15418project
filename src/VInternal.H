/************************************************************************\

  Copyright 1997 The University of North Carolina at Chapel Hill.
  All Rights Reserved.

  Permission to use, copy, modify and distribute this software
  and its documentation for educational, research and non-profit
  purposes, without fee, and without a written agreement is
  hereby granted, provided that the above copyright notice and
  the following three paragraphs appear in all copies.

  IN NO EVENT SHALL THE UNIVERSITY OF NORTH CAROLINA AT CHAPEL
  HILL BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT, SPECIAL,
  INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
  ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
  EVEN IF THE UNIVERSITY OF NORTH CAROLINA HAVE BEEN ADVISED OF
  THE POSSIBILITY OF SUCH DAMAGES.


  Permission to use, copy, modify and distribute this software
  and its documentation for educational, research and non-profit
  purposes, without fee, and without a written agreement is
  hereby granted, provided that the above copyright notice and
  the following three paragraphs appear in all copies.

  THE UNIVERSITY OF NORTH CAROLINA SPECIFICALLY DISCLAIM ANY
  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN "AS IS"
  BASIS, AND THE UNIVERSITY OF NORTH CAROLINA HAS NO OBLIGATION
  TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
  MODIFICATIONS.


   --------------------------------- 
  |Please send all BUG REPORTS to:  |
  |                                 |
  |   geom@cs.unc.edu               |
  |                                 |
   ---------------------------------
  
     
  The authors may be contacted via:

  US Mail:  A. Pattekar/J. Cohen/T. Hudson/S. Gottschalk/M. Lin/D. Manocha
            Department of Computer Science
            Sitterson Hall, CB #3175
            University of N. Carolina
            Chapel Hill, NC 27599-3175
	    
  Phone:    (919)962-1749
	    
  EMail:    geom@cs.unc.edu

\************************************************************************/

/************************************************************************\
Filename: VInternal.H
--
Description: This file declares three classes - VCReportType,
             VCObject and VCInternal.
             VCReportType is a simple class through which
             collisions are reported.
             VCObject holds all the necessary information
             about an object.
             VCInternal contains the implementation of VCollide.

\************************************************************************/


#ifndef VINTERNAL_H
#define VINTERNAL_H

#include "NBody.H"
#include <cuda.h>
#include <cuda_runtime.h>
#include <driver_functions.h>
//state in which VCollide is:
const int VCstate_default   = 0; //default state
const int VCstate_newObject = 1; //a new object has been created but its
                                 //geometry is yet to be inputted.
const int VCstate_addTri    = 2; //the geometry is being inputted.

class Object;
//class VCReportType;
class box;
struct VCReportType
{
  int id1, id2;
};
       //multiply defined in VInternal.C, VCollide.H and VCollide.h
       //this was done so that the implementation can be hidden from the
       //user.

/************************************************************************
Class: VCObject
--
Description: Each instance of this class keeps all the necessary 
             information about an object.

\************************************************************************/

class VCObject
{
  friend class VCInternal;
  
private:
  
  int         id;          //the id of the object.
  Object *b;          //RAPID box for the object. This also stores
                           //the geometry of the object.
  double      trans[16]; //the current transformation matrix for the object.
  box * cuda_store_box;
};


/************************************************************************
Class: VCInternal
--
Description: Each instance of this class maintains information about a
             set of objects and activation/deactivation states between
             them. Collision detection can be performed only on
             objects that belong to the same instance of the this
             class. It uses the NBody class as its back-end.

\************************************************************************/
const int REVERSE  = 1;//whether the direction of movement of the interval
const int FORWARD  = 2;//along the list is forward (FORWARD), reverse (REVERSE)
const int NOCHANGE = 3;//or there is no movement at all (NOCHANGE).
class VCInternal
{
  int      state;       //the state in which VCollide is.
  int      next_id;     //next free id, since ids are generated by the program.
  int      current_id;  //the id of the object being worked on by "AddTri"
                        //or "EndObject".
  int      size;        //size of the "vcobjects" array.
  VCObject **vc_objects;//array of pointers to VCObjects.
  AABB *   boxes;
  AABB *   cuda_boxes;
  int * overlaps;

  int temp_index; 
  int screen_size;
  int overlap_count;
  double * cuda_trans;

  
public:
  VCInternal(int size, int ss);
  ~VCInternal();

  int NewObject(int *id); //create a new object in the database.
  int AddTri(double v1[], double v2[], double v3[]); //insert the
                                                      //geometry .
  int EndObject(void);    //tell VCollide that inserting the 
                          //geometry is complete.
  //int UpdateTrans(int* id, int total, double ** trans);
  int UpdateTrans(int id, double *trans);
   int UpdateAllTrans(int id[], int total, double * trans);
  void AddObject(int id, Object *b);
  int EndAllObjects(void); 
  int all_Collide(void);
                          //update the transformation matrix of
                          //the object.
  int ActivateObject(int id);       //activate for collision detection.
  //__global__ void initAABB(int mySize);


  int Collide(void);  //perform collision detection.

                      //report the results of collision detection.
    
int 
tri_contact (double *P1, double *P2, double *P3,
	     double *Q1, double *Q2, double *Q3);

int obb_disjoint(double B[3][3], double T[3], double a[3], double b[3]);

};




//definition of tri 
struct tri
{
  int id;
  double p1[3], p2[3], p3[3];
};


class box
{
public:
  // placement in parent's space
  // box to parent space: x_m = pR*x_b + pT
  // parent to box space: x_b = pR.T()*(x_m - pT)
  double pR[3][3];
  double pT[3];
  // dimensions
  double d[3];        // this is "radius", that is, 
                      // half the measure of a side length


  int prev_index = -1;
  int next_index = -1;

  tri *trp;

   __host__ __device__ int leaf() { return (prev_index <= 0 && next_index <= 0); } 
  __device__ __host__ double size() { return d[0]; } 
 
  int split_recurse(int *t, int n);
  int split_recurse(int *t);               // specialized for leaf nodes
};


int 
tri_contact (double *P1, double *P2, double *P3,
	     double *Q1, double *Q2, double *Q3);

int
obb_disjoint(double B[3][3], double T[3], double a[3], double b[3]);


class Object
{
public:
  // these are only for internal use

  box *b;
  box *cuda_boxes;
  int num_boxes_alloced;

  tri *tris;
  //tri *cuda_tris;
  int num_tris;
  int num_tris_alloced;

  int build_state;
  
  int build_hierarchy();
  
  int friend Collide(double R1[3][3], double T1[3], 
		 double s1, Object *RAPID_model1,
		 double R2[3][3], double T2[3], 
		 double s2, Object *RAPID_model2, int * collision, int i, int j);
public:

  // these are for the client

  Object();
  ~Object();
  
  int BeginModel();
  int AddTri(const double *p1, const double *p2, const double *p3, int id);
  int EndModel();
  
};

/****************************************************************************/

// these are for the client

const int ALL_CONTACTS = 1;    // Find all pairwise intersecting triangles

const int FIRST_CONTACT = 2;   // Just report one intersecting triangle pair
                               //   if there are any.

// this is the collision query invocation.  It assumes that the 
// models are not being scaled up or down, but have their native
// dimensions.
int 
Collide(double R1[3][3], double T1[3], Object *o1,
	double R2[3][3], double T2[3], Object *o2,
	int flag = ALL_CONTACTS);

// this collision query permits the models to each be scaled by
// some nonnegative factor.
int 
Collide(double R1[3][3], double T1[3], double s1, Object *o1,
	double R2[3][3], double T2[3], double s2, Object *o2,
	int flag = ALL_CONTACTS);

// this is for the client
struct collision_pair
{
  int id1;
  int id2;
};

/****************************************************************************/








#endif
