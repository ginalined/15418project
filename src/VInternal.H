#ifndef VINTERNAL_H
#define VINTERNAL_H

#include "NBody.H"

//state in which VCollide is:
const int VCstate_default   = 0; //default state
const int VCstate_newObject = 1; //a new object has been created but its
                                 //geometry is yet to be inputted.
const int VCstate_addTri    = 2; //the geometry is being inputted.

class Object;
//class VCReportType;

struct VCReportType
{
  int id1, id2;
};
       //multiply defined in VInternal.C, VCollide.H and VCollide.h
       //this was done so that the implementation can be hidden from the
       //user.

/************************************************************************
Class: VCObject
--
Description: Each instance of this class keeps all the necessary 
             information about an object.

\************************************************************************/

class VCObject
{
  friend class VCInternal;
  
private:
  
  int         id;          //the id of the object.
  Object *b;          //RAPID box for the object. This also stores
                           //the geometry of the object.
  
  double      trans[16]; //the current transformation matrix for the object.
  int         activation_state; //1=>object is activated, 0=>deactivated.
};


/************************************************************************
Class: VCInternal
--
Description: Each instance of this class maintains information about a
             set of objects and activation/deactivation states between
             them. Collision detection can be performed only on
             objects that belong to the same instance of the this
             class. It uses the NBody class as its back-end.

\************************************************************************/
const int REVERSE  = 1;//whether the direction of movement of the interval
const int FORWARD  = 2;//along the list is forward (FORWARD), reverse (REVERSE)
const int NOCHANGE = 3;//or there is no movement at all (NOCHANGE).
class VCInternal
{
  int      state;       //the state in which VCollide is.
  int      next_id;     //next free id, since ids are generated by the program.
  int      current_id;  //the id of the object being worked on by "AddTri"
                        //or "EndObject".
  int      size;        //size of the "vcobjects" array.
  VCObject **vc_objects;//array of pointers to VCObjects.
  AABB *   boxes;
  AABB *   cuda_boxes;
  int * overlaps;

  int temp_index; 
  int screen_size;
  int overlap_count;
  double * cuda_trans;

  
public:
  VCInternal(int size, int ss);
  ~VCInternal();

  int NewObject(int *id); //create a new object in the database.
  int AddTri(double v1[], double v2[], double v3[]); //insert the
                                                      //geometry .
  int EndObject(void);    //tell VCollide that inserting the 
                          //geometry is complete.
  //int UpdateTrans(int* id, int total, double ** trans);
  int UpdateTrans(int id, double *trans);
   int UpdateAllTrans(int id[], int total, double * trans);
  void AddObject(int id, Object *b);
  int EndAllObjects(void); 
  int all_Collide(void);
                          //update the transformation matrix of
                          //the object.
  int ActivateObject(int id);       //activate for collision detection.
  //__global__ void initAABB(int mySize);


  int Collide(void);  //perform collision detection.

                      //report the results of collision detection.
    
int 
tri_contact (double *P1, double *P2, double *P3,
	     double *Q1, double *Q2, double *Q3);

int obb_disjoint(double B[3][3], double T[3], double a[3], double b[3]);

};




//definition of tri 
struct tri
{
  int id;
  double p1[3], p2[3], p3[3];
};


class box
{
public:

  // placement in parent's space
  // box to parent space: x_m = pR*x_b + pT
  // parent to box space: x_b = pR.T()*(x_m - pT)
  double pR[3][3];
  double pT[3];

  
  // dimensions
  double d[3];        // this is "radius", that is, 
                      // half the measure of a side length

  box *P;  // points to but does not "own".  
  box *N;

  tri *trp;

  int leaf() { return (!P && !N); } 
  double size() { return d[0]; } 

  int split_recurse(int *t, int n);
  int split_recurse(int *t);               // specialized for leaf nodes
};


int 
tri_contact (double *P1, double *P2, double *P3,
	     double *Q1, double *Q2, double *Q3);

int
obb_disjoint(double B[3][3], double T[3], double a[3], double b[3]);


class Object
{
public:
  // these are only for internal use

  box *b;
  box *cuda_boxes;
  int num_boxes_alloced;

  tri *tris;
  //tri *cuda_tris;
  int num_tris;
  int num_tris_alloced;

  int build_state;
  
  int build_hierarchy();
  
  int friend Collide(double R1[3][3], double T1[3], 
		 double s1, Object *RAPID_model1,
		 double R2[3][3], double T2[3], 
		 double s2, Object *RAPID_model2,
		 int flag);
public:

  // these are for the client

  Object();
  ~Object();
  
  int BeginModel();
  int AddTri(const double *p1, const double *p2, const double *p3, int id);
  int EndModel();
  
};

/****************************************************************************/

// these are for the client

const int ALL_CONTACTS = 1;    // Find all pairwise intersecting triangles

const int FIRST_CONTACT = 2;   // Just report one intersecting triangle pair
                               //   if there are any.

// this is the collision query invocation.  It assumes that the 
// models are not being scaled up or down, but have their native
// dimensions.
int 
Collide(double R1[3][3], double T1[3], Object *o1,
	double R2[3][3], double T2[3], Object *o2,
	int flag = ALL_CONTACTS);

// this collision query permits the models to each be scaled by
// some nonnegative factor.
int 
Collide(double R1[3][3], double T1[3], double s1, Object *o1,
	double R2[3][3], double T2[3], double s2, Object *o2,
	int flag = ALL_CONTACTS);

// this is for the client
struct collision_pair
{
  int id1;
  int id2;
};

/****************************************************************************/

extern int Object_first_contact;
extern  int Object_num_box_tests;
extern  int Object_num_tri_tests;
extern  int Object_num_contacts;
extern  struct collision_pair *Object_contact;







#endif
