/*************************************************************************\

  Copyright 1995 The University of North Carolina at Chapel Hill.
  All Rights Reserved.

  Permission to use, copy, modify and distribute this software and its
  documentation for educational, research and non-profit purposes, without
  fee, and without a written agreement is hereby granted, provided that the
  above copyright notice and the following three paragraphs appear in all
  copies.

  IN NO EVENT SHALL THE UNIVERSITY OF NORTH CAROLINA AT CHAPEL HILL BE
  LIABLE TO ANY PARTY FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR
  CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING OUT OF THE
  USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY
  OF NORTH CAROLINA HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH
  DAMAGES.


  Permission to use, copy, modify and distribute this software and its
  documentation for educational, research and non-profit purposes, without
  fee, and without a written agreement is hereby granted, provided that the
  above copyright notice and the following three paragraphs appear in all
  copies.

  THE UNIVERSITY OF NORTH CAROLINA SPECIFICALLY DISCLAIM ANY
  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE
  PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
  NORTH CAROLINA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,
  UPDATES, ENHANCEMENTS, OR MODIFICATIONS.

  The authors may be contacted via:

  US Mail:             S. Gottschalk
                       Department of Computer Science
                       Sitterson Hall, CB #3175
                       University of N. Carolina
                       Chapel Hill, NC 27599-3175

  Phone:               (919)962-1749

  EMail:              {gottscha}@cs.unc.edu


\**************************************************************************/



#ifndef MATVEC_H
#define MATVEC_H

#include <math.h>
#include <stdio.h>

#include <cuda.h>
#include <cuda_runtime.h>
#include <driver_functions.h>

#ifdef gnu
#include "zzzz.h"

#ifdef hppa
#define myfabs(x) \
 ({double __value, __arg = (x); \
   asm("fabs,dbl %1, %0": "=f" (__value): "f" (__arg)); \
   __value; \
});
#endif

#ifdef mips
#define myfabs(x) \
 ({double __value, __arg = (x); \
   asm("abs.d %0, %1": "=f" (__value): "f" (__arg)); \
   __value; \
});
#endif

#else  

#define myfabs(x) ((x < 0) ? -x : x)

#endif


__device__ __host__ __inline__ void
cuda_MTxV(double Vr[3], double M1[9], double V1[3])
{
  Vr[0] = (M1[0] * V1[0] +
	   M1[3] * V1[1] + 
	   M1[6] * V1[2]); 
  Vr[1] = (M1[1] * V1[0] +
	   M1[4] * V1[1] + 
	   M1[7] * V1[2]);
  Vr[2] = (M1[2] * V1[0] +
	   M1[5] * V1[1] + 
	   M1[8] * V1[2]); 
}
__device__ __host__ __inline__ void
Midentity(double M[3][3])
{
  M[0][0] = M[1][1] = M[2][2] = 1.0;
  M[0][1] = M[1][2] = M[2][0] = 0.0;
  M[0][2] = M[1][0] = M[2][1] = 0.0;
}

__device__ __host__ __inline__ void
McM(double Mr[3][3], double M[3][3])
{
  Mr[0][0] = M[0][0];  Mr[0][1] = M[0][1];  Mr[0][2] = M[0][2];
  Mr[1][0] = M[1][0];  Mr[1][1] = M[1][1];  Mr[1][2] = M[1][2];
  Mr[2][0] = M[2][0];  Mr[2][1] = M[2][1];  Mr[2][2] = M[2][2];
}

__device__ __host__ __inline__ void
VcV(double Vr[3], double V[3])
{
  Vr[0] = V[0];  Vr[1] = V[1];  Vr[2] = V[2];
}

__device__ __host__ __inline__ void
McolcV(double Vr[3], double M[3][3], int c)
{
  Vr[0] = M[0][c];
  Vr[1] = M[1][c];
  Vr[2] = M[2][c];
}

__device__ __host__ __inline__ void
McolcMcol(double Mr[3][3], int cr, double M[3][3], int c)
{
  Mr[0][cr] = M[0][c];
  Mr[1][cr] = M[1][c];
  Mr[2][cr] = M[2][c];
}

__device__ __host__ __inline__ void
MxMpV(double Mr[3][3], double M1[3][3], double M2[3][3], double T[3])
{
  Mr[0][0] = (M1[0][0] * M2[0][0] +
	      M1[0][1] * M2[1][0] +
	      M1[0][2] * M2[2][0] +
	      T[0]);
  Mr[1][0] = (M1[1][0] * M2[0][0] +
	      M1[1][1] * M2[1][0] +
	      M1[1][2] * M2[2][0] +
	      T[1]);
  Mr[2][0] = (M1[2][0] * M2[0][0] +
	      M1[2][1] * M2[1][0] +
	      M1[2][2] * M2[2][0] +
	      T[2]);
  Mr[0][1] = (M1[0][0] * M2[0][1] +
	      M1[0][1] * M2[1][1] +
	      M1[0][2] * M2[2][1] +
	      T[0]);
  Mr[1][1] = (M1[1][0] * M2[0][1] +
	      M1[1][1] * M2[1][1] +
 	      M1[1][2] * M2[2][1] +
	      T[1]);
  Mr[2][1] = (M1[2][0] * M2[0][1] +
	      M1[2][1] * M2[1][1] +
	      M1[2][2] * M2[2][1] +
	      T[2]);
  Mr[0][2] = (M1[0][0] * M2[0][2] +
	      M1[0][1] * M2[1][2] +
	      M1[0][2] * M2[2][2] +
	      T[0]);
  Mr[1][2] = (M1[1][0] * M2[0][2] +
	      M1[1][1] * M2[1][2] +
	      M1[1][2] * M2[2][2] +
	      T[1]);
  Mr[2][2] = (M1[2][0] * M2[0][2] +
	      M1[2][1] * M2[1][2] +
	      M1[2][2] * M2[2][2] +
	      T[2]);
}

__device__ __host__ __inline__ void
MxM(double Mr[3][3], double M1[3][3], double M2[3][3])
{
  Mr[0][0] = (M1[0][0] * M2[0][0] +
	      M1[0][1] * M2[1][0] +
	      M1[0][2] * M2[2][0]);
  Mr[1][0] = (M1[1][0] * M2[0][0] +
	      M1[1][1] * M2[1][0] +
	      M1[1][2] * M2[2][0]);
  Mr[2][0] = (M1[2][0] * M2[0][0] +
	      M1[2][1] * M2[1][0] +
	      M1[2][2] * M2[2][0]);
  Mr[0][1] = (M1[0][0] * M2[0][1] +
	      M1[0][1] * M2[1][1] +
	      M1[0][2] * M2[2][1]);
  Mr[1][1] = (M1[1][0] * M2[0][1] +
	      M1[1][1] * M2[1][1] +
 	      M1[1][2] * M2[2][1]);
  Mr[2][1] = (M1[2][0] * M2[0][1] +
	      M1[2][1] * M2[1][1] +
	      M1[2][2] * M2[2][1]);
  Mr[0][2] = (M1[0][0] * M2[0][2] +
	      M1[0][1] * M2[1][2] +
	      M1[0][2] * M2[2][2]);
  Mr[1][2] = (M1[1][0] * M2[0][2] +
	      M1[1][1] * M2[1][2] +
	      M1[1][2] * M2[2][2]);
  Mr[2][2] = (M1[2][0] * M2[0][2] +
	      M1[2][1] * M2[1][2] +
	      M1[2][2] * M2[2][2]);
}

__device__ __host__ __inline__ void
MxMT(double Mr[3][3], double M1[3][3], double M2[3][3])
{
  Mr[0][0] = (M1[0][0] * M2[0][0] +
	      M1[0][1] * M2[0][1] +
	      M1[0][2] * M2[0][2]);
  Mr[1][0] = (M1[1][0] * M2[0][0] +
	      M1[1][1] * M2[0][1] +
	      M1[1][2] * M2[0][2]);
  Mr[2][0] = (M1[2][0] * M2[0][0] +
	      M1[2][1] * M2[0][1] +
	      M1[2][2] * M2[0][2]);
  Mr[0][1] = (M1[0][0] * M2[1][0] +
	      M1[0][1] * M2[1][1] +
	      M1[0][2] * M2[1][2]);
  Mr[1][1] = (M1[1][0] * M2[1][0] +
	      M1[1][1] * M2[1][1] +
 	      M1[1][2] * M2[1][2]);
  Mr[2][1] = (M1[2][0] * M2[1][0] +
	      M1[2][1] * M2[1][1] +
	      M1[2][2] * M2[1][2]);
  Mr[0][2] = (M1[0][0] * M2[2][0] +
	      M1[0][1] * M2[2][1] +
	      M1[0][2] * M2[2][2]);
  Mr[1][2] = (M1[1][0] * M2[2][0] +
	      M1[1][1] * M2[2][1] +
	      M1[1][2] * M2[2][2]);
  Mr[2][2] = (M1[2][0] * M2[2][0] +
	      M1[2][1] * M2[2][1] +
	      M1[2][2] * M2[2][2]);
}

__device__ __host__ __inline__ void
MTxM(double Mr[3][3], double M1[3][3], double M2[3][3])
{
  Mr[0][0] = (M1[0][0] * M2[0][0] +
	      M1[1][0] * M2[1][0] +
	      M1[2][0] * M2[2][0]);
  Mr[1][0] = (M1[0][1] * M2[0][0] +
	      M1[1][1] * M2[1][0] +
	      M1[2][1] * M2[2][0]);
  Mr[2][0] = (M1[0][2] * M2[0][0] +
	      M1[1][2] * M2[1][0] +
	      M1[2][2] * M2[2][0]);
  Mr[0][1] = (M1[0][0] * M2[0][1] +
	      M1[1][0] * M2[1][1] +
	      M1[2][0] * M2[2][1]);
  Mr[1][1] = (M1[0][1] * M2[0][1] +
	      M1[1][1] * M2[1][1] +
 	      M1[2][1] * M2[2][1]);
  Mr[2][1] = (M1[0][2] * M2[0][1] +
	      M1[1][2] * M2[1][1] +
	      M1[2][2] * M2[2][1]);
  Mr[0][2] = (M1[0][0] * M2[0][2] +
	      M1[1][0] * M2[1][2] +
	      M1[2][0] * M2[2][2]);
  Mr[1][2] = (M1[0][1] * M2[0][2] +
	      M1[1][1] * M2[1][2] +
	      M1[2][1] * M2[2][2]);
  Mr[2][2] = (M1[0][2] * M2[0][2] +
	      M1[1][2] * M2[1][2] +
	      M1[2][2] * M2[2][2]);
}

__device__ __host__ __inline__ void
MxV(double Vr[3], double M1[3][3], double V1[3])
{
  Vr[0] = (M1[0][0] * V1[0] +
	   M1[0][1] * V1[1] + 
	   M1[0][2] * V1[2]);
  Vr[1] = (M1[1][0] * V1[0] +
	   M1[1][1] * V1[1] + 
	   M1[1][2] * V1[2]);
  Vr[2] = (M1[2][0] * V1[0] +
	   M1[2][1] * V1[1] + 
	   M1[2][2] * V1[2]);
}


__device__ __host__ __inline__ void
MxVpV(double Vr[3], double M1[3][3], double V1[3], double V2[3])
{
  Vr[0] = (M1[0][0] * V1[0] +
	   M1[0][1] * V1[1] + 
	   M1[0][2] * V1[2] + 
	   V2[0]);
  Vr[1] = (M1[1][0] * V1[0] +
	   M1[1][1] * V1[1] + 
	   M1[1][2] * V1[2] + 
	   V2[1]);
  Vr[2] = (M1[2][0] * V1[0] +
	   M1[2][1] * V1[1] + 
	   M1[2][2] * V1[2] + 
	   V2[2]);
}

__device__ __host__ __inline__ void
sMxVpV(double Vr[3], double s1, double M1[3][3], double V1[3], double V2[3])
{
  Vr[0] = s1 * (M1[0][0] * V1[0] +
		M1[0][1] * V1[1] + 
		M1[0][2] * V1[2]) +
		V2[0];
  Vr[1] = s1 * (M1[1][0] * V1[0] +
		M1[1][1] * V1[1] + 
		M1[1][2] * V1[2]) + 
		V2[1];
  Vr[2] = s1 * (M1[2][0] * V1[0] +
		M1[2][1] * V1[1] + 
		M1[2][2] * V1[2]) + 
		V2[2];
}

__device__ __host__ __inline__ void
MTxV(double Vr[3], double M1[3][3], double V1[3])
{
  Vr[0] = (M1[0][0] * V1[0] +
	   M1[1][0] * V1[1] + 
	   M1[2][0] * V1[2]); 
  Vr[1] = (M1[0][1] * V1[0] +
	   M1[1][1] * V1[1] + 
	   M1[2][1] * V1[2]);
  Vr[2] = (M1[0][2] * V1[0] +
	   M1[1][2] * V1[1] + 
	   M1[2][2] * V1[2]); 
}

__device__ __host__ __inline__ void
sMTxV(double Vr[3], double s1, double M1[3][3], double V1[3])
{
  Vr[0] = s1*(M1[0][0] * V1[0] +
	      M1[1][0] * V1[1] + 
	      M1[2][0] * V1[2]); 
  Vr[1] = s1*(M1[0][1] * V1[0] +
	      M1[1][1] * V1[1] + 
	      M1[2][1] * V1[2]);
  Vr[2] = s1*(M1[0][2] * V1[0] +
	      M1[1][2] * V1[1] + 
	      M1[2][2] * V1[2]); 
}


__device__ __host__ __inline__ void 
VmV(double Vr[3], const double V1[3], const double V2[3])
{
  Vr[0] = V1[0] - V2[0];
  Vr[1] = V1[1] - V2[1];
  Vr[2] = V1[2] - V2[2];
}

__device__ __host__ __inline__ void
VpV(double Vr[3], double V1[3], double V2[3])
{
  Vr[0] = V1[0] + V2[0];
  Vr[1] = V1[1] + V2[1];
  Vr[2] = V1[2] + V2[2];
}

__device__ __host__ __inline__ void
VpVxS(double Vr[3], double V1[3], double V2[3], double s)
{
  Vr[0] = V1[0] + V2[0] * s;
  Vr[1] = V1[1] + V2[1] * s;
  Vr[2] = V1[2] + V2[2] * s;
}

__device__ __host__ __inline__ void
MskewV(double M[3][3], const double v[3])
{
  M[0][0] = M[1][1] = M[2][2] = 0.0;
  M[1][0] = v[2];
  M[0][1] = -v[2];
  M[0][2] = v[1];
  M[2][0] = -v[1];
  M[1][2] = -v[0];
  M[2][1] = v[0];
}


__device__ __host__ __inline__ void
VcrossV(double Vr[3], const double V1[3], const double V2[3])
{
  Vr[0] = V1[1]*V2[2] - V1[2]*V2[1];
  Vr[1] = V1[2]*V2[0] - V1[0]*V2[2];
  Vr[2] = V1[0]*V2[1] - V1[1]*V2[0];
}


__device__ __host__ __inline__ double
Vlength(double V[3])
{
  return sqrt(V[0]*V[0] + V[1]*V[1] + V[2]*V[2]);
}

__device__ __host__ __inline__ void
Vnormalize(double V[3])
{
  double d = 1.0 / sqrt(V[0]*V[0] + V[1]*V[1] + V[2]*V[2]);
  V[0] *= d;
  V[1] *= d;
  V[2] *= d;
}


__device__ __host__ __inline__ double
VdotV(double V1[3], double V2[3])
{
  return (V1[0]*V2[0] + V1[1]*V2[1] + V1[2]*V2[2]);
}


__device__ __host__ void
VxS(double Vr[3], double V[3], double s)
{
  Vr[0] = V[0] * s;
  Vr[1] = V[1] * s;
  Vr[2] = V[2] * s;
}


__device__ __host__ void
Mqinverse(double Mr[3][3], double m[3][3])
{
  int i,j;

  for(i=0; i<3; i++)
    for(j=0; j<3; j++)
      {
	int i1 = (i+1)%3;
	int i2 = (i+2)%3;
	int j1 = (j+1)%3;
	int j2 = (j+2)%3;
	Mr[i][j] = (m[j1][i1]*m[j2][i2] - m[j1][i2]*m[j2][i1]);
      }
}


#define rfabs(x) ((x < 0) ? -x : x)

#define ROT(a,i,j,k,l) g=a[i][j]; h=a[k][l]; a[i][j]=g-s*(h+g*tau); a[k][l]=h+s*(g-h*tau);

__device__ __host__ int
Meigen(double vout[3][3], double dout[3], double a[3][3])
{
  int i;
  double tresh,theta,tau,t,sm,s,h,g,c;
  int nrot;
  double b[3];
  double z[3];
  double v[3][3];
  double d[3];
  
  v[0][0] = v[1][1] = v[2][2] = 1.0;
  v[0][1] = v[1][2] = v[2][0] = 0.0;
  v[0][2] = v[1][0] = v[2][1] = 0.0;
  
  b[0] = a[0][0]; d[0] = a[0][0]; z[0] = 0.0;
  b[1] = a[1][1]; d[1] = a[1][1]; z[1] = 0.0;
  b[2] = a[2][2]; d[2] = a[2][2]; z[2] = 0.0;

  nrot = 0;
  
  for(i=0; i<50; i++)
    {

      sm=0.0; sm+=fabs(a[0][1]); sm+=fabs(a[0][2]); sm+=fabs(a[1][2]);
      if (sm == 0.0) { McM(vout,v); VcV(dout,d); return i; }
      
      if (i < 3) tresh=0.2*sm/(3*3); else tresh=0.0;
      
      {
	g = 100.0*rfabs(a[0][1]);  
	if (i>3 && rfabs(d[0])+g==rfabs(d[0]) && rfabs(d[1])+g==rfabs(d[1]))
	  a[0][1]=0.0;
	else if (rfabs(a[0][1])>tresh)
	  {
	    h = d[1]-d[0];
	    if (rfabs(h)+g == rfabs(h)) t=(a[0][1])/h;
	    else
	      {
		theta=0.5*h/(a[0][1]);
		t=1.0/(rfabs(theta)+sqrt(1.0+theta*theta));
		if (theta < 0.0) t = -t;
	      }
	    c=1.0/sqrt(1+t*t); s=t*c; tau=s/(1.0+c); h=t*a[0][1];
	    z[0] -= h; z[1] += h; d[0] -= h; d[1] += h;
	    a[0][1]=0.0;
	    ROT(a,0,2,1,2); ROT(v,0,0,0,1); ROT(v,1,0,1,1); ROT(v,2,0,2,1); 
	    nrot++;
	  }
      }

      {
	g = 100.0*rfabs(a[0][2]);
	if (i>3 && rfabs(d[0])+g==rfabs(d[0]) && rfabs(d[2])+g==rfabs(d[2]))
	  a[0][2]=0.0;
	else if (rfabs(a[0][2])>tresh)
	  {
	    h = d[2]-d[0];
	    if (rfabs(h)+g == rfabs(h)) t=(a[0][2])/h;
	    else
	      {
		theta=0.5*h/(a[0][2]);
		t=1.0/(rfabs(theta)+sqrt(1.0+theta*theta));
		if (theta < 0.0) t = -t;
	      }
	    c=1.0/sqrt(1+t*t); s=t*c; tau=s/(1.0+c); h=t*a[0][2];
	    z[0] -= h; z[2] += h; d[0] -= h; d[2] += h;
	    a[0][2]=0.0;
	    ROT(a,0,1,1,2); ROT(v,0,0,0,2); ROT(v,1,0,1,2); ROT(v,2,0,2,2); 
	    nrot++;
	  }
      }


      {
	g = 100.0*rfabs(a[1][2]);
	if (i>3 && rfabs(d[1])+g==rfabs(d[1]) && rfabs(d[2])+g==rfabs(d[2]))
	  a[1][2]=0.0;
	else if (rfabs(a[1][2])>tresh)
	  {
	    h = d[2]-d[1];
	    if (rfabs(h)+g == rfabs(h)) t=(a[1][2])/h;
	    else
	      {
		theta=0.5*h/(a[1][2]);
		t=1.0/(rfabs(theta)+sqrt(1.0+theta*theta));
		if (theta < 0.0) t = -t;
	      }
	    c=1.0/sqrt(1+t*t); s=t*c; tau=s/(1.0+c); h=t*a[1][2];
	    z[1] -= h; z[2] += h; d[1] -= h; d[2] += h;
	    a[1][2]=0.0;
	    ROT(a,0,1,0,2); ROT(v,0,1,0,2); ROT(v,1,1,1,2); ROT(v,2,1,2,2); 
	    nrot++;
	  }
      }

      b[0] += z[0]; d[0] = b[0]; z[0] = 0.0;
      b[1] += z[1]; d[1] = b[1]; z[1] = 0.0;
      b[2] += z[2]; d[2] = b[2]; z[2] = 0.0;
      
    }

  //fprintf(stderr, "eigen: too many iterations in Jacobi transform (%d).\n", i);

  return i;
}

__device__ __host__  int
eigen_and_sort1(double evecs[3][3], double cov[3][3])
{
  double t;
  double evals[3];
  int n;

  n = Meigen(evecs, evals, cov);
  
  if (evals[2] > evals[0])
    {
      if (evals[2] > evals[1])
	{
	  // 2 is largest, swap with column 0
	  t = evecs[0][2]; 
	  evecs[0][2] = evecs[0][0]; 
	  evecs[0][0] = t;
	  t = evecs[1][2]; 
	  evecs[1][2] = evecs[1][0]; 
	  evecs[1][0] = t;
	  t = evecs[2][2]; 
	  evecs[2][2] = evecs[2][0]; 
	  evecs[2][0] = t;
	}
      else
	{
	  // 1 is largest, swap with column 0
	  t = evecs[0][1]; 
	  evecs[0][1] = evecs[0][0]; 
	  evecs[0][0] = t;
	  t = evecs[1][1]; 
	  evecs[1][1] = evecs[1][0]; 
	  evecs[1][0] = t;
	  t = evecs[2][1]; 
	  evecs[2][1] = evecs[2][0]; 
	  evecs[2][0] = t;
	}
    }
  else
    {
      if (evals[0] > evals[1])
	{
	  // 0 is largest, do nothing
	}
      else
	{
  	  // 1 is largest
	  t = evecs[0][1]; 
	  evecs[0][1] = evecs[0][0]; 
	  evecs[0][0] = t;
	  t = evecs[1][1]; 
	  evecs[1][1] = evecs[1][0]; 
	  evecs[1][0] = t;
	  t = evecs[2][1]; 
	  evecs[2][1] = evecs[2][0]; 
	  evecs[2][0] = t;
	}
    }

  // we are returning the number of iterations Meigen took.
  // too many iterations means our chosen orientation is bad.
  return n; 
}


__device__ __host__ __inline__ void
minmax(double &mn, double &mx, double v)
{
  if (v < mn) mn = v;
  else if (v > mx) mx = v;
}

struct moment
{
  double A;  
  double m[3];
  double s[3][3];
};

struct accum
{
  double A;
  double m[3];
  double s[3][3];
};

__device__ __host__ __inline__ void
clear_accum(accum &a)
{
  a.m[0] = a.m[1] = a.m[2] = 0.0;
  a.s[0][0] = a.s[0][1] = a.s[0][2] = 0.0;
  a.s[1][0] = a.s[1][1] = a.s[1][2] = 0.0;
  a.s[2][0] = a.s[2][1] = a.s[2][2] = 0.0;
  a.A = 0.0;
}

__device__ __host__ __inline__ void
accum_moment(accum &a, moment &b)
{
  for (int i = 0; i < 3;i++){
    a.m[i] += b.m[i] * b.A;
    a.s[i][0] += b.s[i][0];
    a.s[i][1] += b.s[i][1];
    a.s[i][2] += b.s[i][2];
  }

  a.A += b.A;
}

__device__ __host__ void
mean_from_moment(double M[3], moment &m)
{
  M[0] = m.m[0];
  M[1] = m.m[1];
  M[2] = m.m[2];
}

__device__ __host__ void
mean_from_accum(double M[3], accum &a)
{
  M[0] = a.m[0] / a.A;
  M[1] = a.m[1] / a.A;
  M[2] = a.m[2] / a.A;
}

__device__ __host__ void
covariance_from_accum(double C[3][3], accum &a)
{
  int i,j;
  for(i=0; i<3; i++)
    for(j=0; j<3; j++)
      C[i][j] = a.s[i][j] - a.m[i]*a.m[j]/a.A;
}



__device__ __host__ void
compute_moment(moment &M, double p[3], double q[3], double r[3])
{
  double u[3], v[3], w[3];

  // compute the area of the triangle
  VmV(u, q, p);
  VmV(v, r, p);
  VcrossV(w, u, v);
  M.A = 0.5 * Vlength(w);

 
  // get the centroid
  M.m[0] = (p[0] + q[0] + r[0])/3;
  M.m[1] = (p[1] + q[1] + r[1])/3;
  M.m[2] = (p[2] + q[2] + r[2])/3;

  // get the second order components -- note the weighting by the area
  M.s[0][0] = M.A*(9*M.m[0]*M.m[0]+p[0]*p[0]+q[0]*q[0]+r[0]*r[0])/12;
  M.s[0][1] = M.A*(9*M.m[0]*M.m[1]+p[0]*p[1]+q[0]*q[1]+r[0]*r[1])/12;
  M.s[1][1] = M.A*(9*M.m[1]*M.m[1]+p[1]*p[1]+q[1]*q[1]+r[1]*r[1])/12;
  M.s[0][2] = M.A*(9*M.m[0]*M.m[2]+p[0]*p[2]+q[0]*q[2]+r[0]*r[2])/12;
  M.s[1][2] = M.A*(9*M.m[1]*M.m[2]+p[1]*p[2]+q[1]*q[2]+r[1]*r[2])/12;
  M.s[2][2] = M.A*(9*M.m[2]*M.m[2]+p[2]*p[2]+q[2]*q[2]+r[2]*r[2])/12;
  M.s[2][1] = M.s[1][2];
  M.s[1][0] = M.s[0][1];
  M.s[2][0] = M.s[0][2];
}

__device__ __host__ void
compute_moments(moment *M, tri *tris, int num_tris)
{
  double Amin = 0.0;
  int zero = 0;
  for(int i=0; i<num_tris; i++)
    {
      compute_moment(M[i], 
		     tris[i].p1,
		     tris[i].p2, 
		     tris[i].p3);  

	  if (Amin == 0.0) Amin = M[i].A;
	  else if (M[i].A < Amin) Amin = M[i].A;
	}
}




__global__ void exclusive_scan_up_sweep_kernel(int N, int twod, int *data, int twod1) {
    int index = blockIdx.x * blockDim.x + threadIdx.x;

    if (index >= N)  return;

    if (index % twod1 == 0) {
        data[index + twod1 - 1] += data[index + twod - 1];
    }
}

__global__ void exclusive_scan_down_sweep_kernel(int N, int twod, int *data, int twod1) {
    int index = blockIdx.x * blockDim.x + threadIdx.x;

    if (index >= N)  return;
    
    if (index % twod1 == 0) {
        int t = data[index + twod - 1];
        data[index + twod - 1] = data[index + twod1 - 1];
        data[index + twod1 - 1] += t;
    }
}

__global__ void mark_peaks_kernel(int *data, int length, int *device_output) {
    int index = blockIdx.x * blockDim.x + threadIdx.x;

    if (index <= 0 || index >= length - 1)  return;

    bool is_gt_left = data[index - 1] < data[index];
    bool is_gt_right = data[index + 1] < data[index];
    if (is_gt_left && is_gt_right) {
        device_output[index] = 1;
    }
}

__global__ void distribute_kernel(int N, int *arr) {
    //compute overall index from position of thread in current block,
    //and given the block we are in
    int i = blockIdx.x * blockDim.x + threadIdx.x;
    if(i!=0 && i<=N-1 && arr[i-1] < arr[i]){
        arr[arr[i-1]] = i-1;
    }  
}

void exclusive_scan(int* device_data, int length)
{
  const int threadsPerBlock = 128;
    const int blocks = (length + threadsPerBlock - 1) / threadsPerBlock;
    // upsweep phase
    for (int twod = 1; twod < length; twod = twod << 1) {
        exclusive_scan_up_sweep_kernel<<<blocks, threadsPerBlock>>>(length, twod, device_data, twod << 1);
    }



    //device_data[length - 1] = 0;
    cudaMemset(device_data + length -1 ,0, sizeof(int));
    //   int* dev = new int[1024];
    // cudaMemcpy(dev, device_data, sizeof(int)*1024, cudaMemcpyDeviceToHost);
    // for (int i = 0; i < 1024;i++){
    //   printf("%d ", dev[i]);
    // }
    //printf("\n");
    // downsweep phase
    for (int twod = length >> 1; twod >= 1; twod = twod >> 1) {
        exclusive_scan_down_sweep_kernel<<<blocks, threadsPerBlock>>>(length, twod, device_data, twod << 1);
    }

}

__host__ __device__ int obb_disjoint(double B[3][3], double T[3], double a[3], double b[3]) {
  register double t, s;
  register int r;
  double Bf[3][3];
  const double reps = 1e-6;

  // Bf = fabs(B)
  Bf[0][0] = myfabs(B[0][0]);
  Bf[0][0] += reps;
  Bf[0][1] = myfabs(B[0][1]);
  Bf[0][1] += reps;
  Bf[0][2] = myfabs(B[0][2]);
  Bf[0][2] += reps;
  Bf[1][0] = myfabs(B[1][0]);
  Bf[1][0] += reps;
  Bf[1][1] = myfabs(B[1][1]);
  Bf[1][1] += reps;
  Bf[1][2] = myfabs(B[1][2]);
  Bf[1][2] += reps;
  Bf[2][0] = myfabs(B[2][0]);
  Bf[2][0] += reps;
  Bf[2][1] = myfabs(B[2][1]);
  Bf[2][1] += reps;
  Bf[2][2] = myfabs(B[2][2]);
  Bf[2][2] += reps;

  // if any of these tests are one-sided, then the polyhedra are disjoint
  r = 1;

  // A1 x A2 = A0
  t = myfabs(T[0]);

  r &= (t <= (a[0] + b[0] * Bf[0][0] + b[1] * Bf[0][1] + b[2] * Bf[0][2]));
  if (!r)
    return 1;

  // B1 x B2 = B0
  s = T[0] * B[0][0] + T[1] * B[1][0] + T[2] * B[2][0];
  t = myfabs(s);

  r &= (t <= (b[0] + a[0] * Bf[0][0] + a[1] * Bf[1][0] + a[2] * Bf[2][0]));
  if (!r)
    return 2;

  // A2 x A0 = A1
  t = myfabs(T[1]);

  r &= (t <= (a[1] + b[0] * Bf[1][0] + b[1] * Bf[1][1] + b[2] * Bf[1][2]));
  if (!r)
    return 3;

  // A0 x A1 = A2
  t = myfabs(T[2]);

  r &= (t <= (a[2] + b[0] * Bf[2][0] + b[1] * Bf[2][1] + b[2] * Bf[2][2]));
  if (!r)
    return 4;

  // B2 x B0 = B1
  s = T[0] * B[0][1] + T[1] * B[1][1] + T[2] * B[2][1];
  t = myfabs(s);

  r &= (t <= (b[1] + a[0] * Bf[0][1] + a[1] * Bf[1][1] + a[2] * Bf[2][1]));
  if (!r)
    return 5;

  // B0 x B1 = B2
  s = T[0] * B[0][2] + T[1] * B[1][2] + T[2] * B[2][2];
  t = myfabs(s);

  r &= (t <= (b[2] + a[0] * Bf[0][2] + a[1] * Bf[1][2] + a[2] * Bf[2][2]));
  if (!r)
    return 6;

  // A0 x B0
  s = T[2] * B[1][0] - T[1] * B[2][0];
  t = myfabs(s);

  r &= (t <= (a[1] * Bf[2][0] + a[2] * Bf[1][0] + b[1] * Bf[0][2] +
              b[2] * Bf[0][1]));
  if (!r)
    return 7;

  // A0 x B1
  s = T[2] * B[1][1] - T[1] * B[2][1];
  t = myfabs(s);

  r &= (t <= (a[1] * Bf[2][1] + a[2] * Bf[1][1] + b[0] * Bf[0][2] +
              b[2] * Bf[0][0]));
  if (!r)
    return 8;

  // A0 x B2
  s = T[2] * B[1][2] - T[1] * B[2][2];
  t = myfabs(s);

  r &= (t <= (a[1] * Bf[2][2] + a[2] * Bf[1][2] + b[0] * Bf[0][1] +
              b[1] * Bf[0][0]));
  if (!r)
    return 9;

  // A1 x B0
  s = T[0] * B[2][0] - T[2] * B[0][0];
  t = myfabs(s);

  r &= (t <= (a[0] * Bf[2][0] + a[2] * Bf[0][0] + b[1] * Bf[1][2] +
              b[2] * Bf[1][1]));
  if (!r)
    return 10;

  // A1 x B1
  s = T[0] * B[2][1] - T[2] * B[0][1];
  t = myfabs(s);

  r &= (t <= (a[0] * Bf[2][1] + a[2] * Bf[0][1] + b[0] * Bf[1][2] +
              b[2] * Bf[1][0]));
  if (!r)
    return 11;

  // A1 x B2
  s = T[0] * B[2][2] - T[2] * B[0][2];
  t = myfabs(s);

  r &= (t <= (a[0] * Bf[2][2] + a[2] * Bf[0][2] + b[0] * Bf[1][1] +
              b[1] * Bf[1][0]));
  if (!r)
    return 12;

  // A2 x B0
  s = T[1] * B[0][0] - T[0] * B[1][0];
  t = myfabs(s);

  r &= (t <= (a[0] * Bf[1][0] + a[1] * Bf[0][0] + b[1] * Bf[2][2] +
              b[2] * Bf[2][1]));
  if (!r)
    return 13;

  // A2 x B1
  s = T[1] * B[0][1] - T[0] * B[1][1];
  t = myfabs(s);

  r &= (t <= (a[0] * Bf[1][1] + a[1] * Bf[0][1] + b[0] * Bf[2][2] +
              b[2] * Bf[2][0]));
  if (!r)
    return 14;

  // A2 x B2
  s = T[1] * B[0][2] - T[0] * B[1][2];
  t = myfabs(s);

  r &= (t <= (a[0] * Bf[1][2] + a[1] * Bf[0][2] + b[0] * Bf[2][1] +
              b[1] * Bf[2][0]));
  if (!r)
    return 15;

  return 0; // should equal 0
}

__host__ __device__ double max(double a, double b, double c) {
  double t = a;
  if (b > t)
    t = b;
  if (c > t)
    t = c;
  return t;
}

__host__ __device__ double min(double a, double b, double c) {
  double t = a;
  if (b < t)
    t = b;
  if (c < t)
    t = c;
  return t;
}

__host__ __device__ int project6(double *ax, double *p1, double *p2, double *p3, double *q1,
             double *q2, double *q3) {
  double P1 = VdotV(ax, p1);
  double P2 = VdotV(ax, p2);
  double P3 = VdotV(ax, p3);
  double Q1 = VdotV(ax, q1);
  double Q2 = VdotV(ax, q2);
  double Q3 = VdotV(ax, q3);

  double mx1 = max(P1, P2, P3);
  double mn1 = min(P1, P2, P3);
  double mx2 = max(Q1, Q2, Q3);
  double mn2 = min(Q1, Q2, Q3);

  if (mn1 > mx2)
    return 0;
  if (mn2 > mx1)
    return 0;
  return 1;
}
__host__ __device__ int tri_contact(double *P1, double *P2, double *P3, double *Q1, double *Q2,
                double *Q3) {

  double p1[3], p2[3], p3[3];
  double q1[3], q2[3], q3[3];
  double e1[3], e2[3], e3[3];
  double f1[3], f2[3], f3[3];
  double g1[3], g2[3], g3[3];
  double h1[3], h2[3], h3[3];
  double n1[3], m1[3];


  double ef11[3], ef12[3], ef13[3];
  double ef21[3], ef22[3], ef23[3];
  double ef31[3], ef32[3], ef33[3];


  p1[0] = P1[0] - P1[0];
  p1[1] = P1[1] - P1[1];
  p1[2] = P1[2] - P1[2];
  p2[0] = P2[0] - P1[0];
  p2[1] = P2[1] - P1[1];
  p2[2] = P2[2] - P1[2];
  p3[0] = P3[0] - P1[0];
  p3[1] = P3[1] - P1[1];
  p3[2] = P3[2] - P1[2];

  q1[0] = Q1[0] - P1[0];
  q1[1] = Q1[1] - P1[1];
  q1[2] = Q1[2] - P1[2];
  q2[0] = Q2[0] - P1[0];
  q2[1] = Q2[1] - P1[1];
  q2[2] = Q2[2] - P1[2];
  q3[0] = Q3[0] - P1[0];
  q3[1] = Q3[1] - P1[1];
  q3[2] = Q3[2] - P1[2];

  e1[0] = p2[0] - p1[0];
  e1[1] = p2[1] - p1[1];
  e1[2] = p2[2] - p1[2];
  e2[0] = p3[0] - p2[0];
  e2[1] = p3[1] - p2[1];
  e2[2] = p3[2] - p2[2];
  e3[0] = p1[0] - p3[0];
  e3[1] = p1[1] - p3[1];
  e3[2] = p1[2] - p3[2];

  f1[0] = q2[0] - q1[0];
  f1[1] = q2[1] - q1[1];
  f1[2] = q2[2] - q1[2];
  f2[0] = q3[0] - q2[0];
  f2[1] = q3[1] - q2[1];
  f2[2] = q3[2] - q2[2];
  f3[0] = q1[0] - q3[0];
  f3[1] = q1[1] - q3[1];
  f3[2] = q1[2] - q3[2];

  VcrossV(n1, e1, e2);
  VcrossV(m1, f1, f2);

  VcrossV(g1, e1, n1);
  VcrossV(g2, e2, n1);
  VcrossV(g3, e3, n1);
  VcrossV(h1, f1, m1);
  VcrossV(h2, f2, m1);
  VcrossV(h3, f3, m1);

  VcrossV(ef11, e1, f1);
  VcrossV(ef12, e1, f2);
  VcrossV(ef13, e1, f3);
  VcrossV(ef21, e2, f1);
  VcrossV(ef22, e2, f2);
  VcrossV(ef23, e2, f3);
  VcrossV(ef31, e3, f1);
  VcrossV(ef32, e3, f2);
  VcrossV(ef33, e3, f3);

  // now begin the series of tests

  if (!project6(n1, p1, p2, p3, q1, q2, q3))
    return 0;
  if (!project6(m1, p1, p2, p3, q1, q2, q3))
    return 0;

  if (!project6(ef11, p1, p2, p3, q1, q2, q3))
    return 0;
  if (!project6(ef12, p1, p2, p3, q1, q2, q3))
    return 0;
  if (!project6(ef13, p1, p2, p3, q1, q2, q3))
    return 0;
  if (!project6(ef21, p1, p2, p3, q1, q2, q3))
    return 0;
  if (!project6(ef22, p1, p2, p3, q1, q2, q3))
    return 0;
  if (!project6(ef23, p1, p2, p3, q1, q2, q3))
    return 0;
  if (!project6(ef31, p1, p2, p3, q1, q2, q3))
    return 0;
  if (!project6(ef32, p1, p2, p3, q1, q2, q3))
    return 0;
  if (!project6(ef33, p1, p2, p3, q1, q2, q3))
    return 0;

  if (!project6(g1, p1, p2, p3, q1, q2, q3))
    return 0;
  if (!project6(g2, p1, p2, p3, q1, q2, q3))
    return 0;
  if (!project6(g3, p1, p2, p3, q1, q2, q3))
    return 0;
  if (!project6(h1, p1, p2, p3, q1, q2, q3))
    return 0;
  if (!project6(h2, p1, p2, p3, q1, q2, q3))
    return 0;
  if (!project6(h3, p1, p2, p3, q1, q2, q3))
    return 0;

  return 1;
}


int find_peaks(int length, int *device_output) {
   
    if (length <= 2)    return 0;
    //printf("length is %d", length);
    // compute number of blocks and threads per block
    const int threadsPerBlock = 128;
    const int blocks = (length + threadsPerBlock - 1) / threadsPerBlock;
   
    

    exclusive_scan(device_output, length);
     
    
    int result = 0;
    cudaMemcpy(&result, device_output + (length - 1), sizeof(int), cudaMemcpyDeviceToHost);
    

    
    distribute_kernel<<<blocks, threadsPerBlock>>>(length, device_output);
      
    return result;
}




#endif
